# 排序

排序应该算是算法里面最基础也是最简单的内容了，一般来说，初中的NOIP选手都能熟练掌握各种排序算法。虽然简单，我们还是能从各种排序的思想里面学到很多想法 ，所以我还是在这里总结一下各种排序算法。

## 选择排序

每次从无序数组里选一个最小的，放到有序数组最后。

```cpp
for (int i=0; i<n; i++) {
	int mij = i;
	for (int j=i+1; j<n; j++) {
		if (a[j] < a[mij]) mij = j;
	}
	swap(a[i], a[mij]);
}
```

## 插入排序

每次把无序数组的第一个元素插入到当前有序数组的适当位置。

```cpp
for (int i=1; i<n; i++) {
	int tmp = a[i];
	int j = i-1;
	while (j >= 0 && a[j] > tmp) {
		a[j+1] = a[j];
		j --;
	}
	a[j+1] = tmp;
}
```

## 希尔排序

每次以h为间隔做插入排序，h从某个数开始每次/3直到变成1。原理是观察到插入排序对于有序数组的排序效率很高，所以希尔排序让数组先局部有序。

```cpp
int h = 1;
while (h < n / 3) h = h * 3 + 1;
while (h) {
	for (int i=h; i<n; i++) {
		int j = i;
		while (j - h >= 0 && a[j] < a[j-h]) {
			swap(a[j], a[j-h]);
			j -= h;
		}
	}
	h /= 3;
}
```

## 归并排序

一种递归的方法，先把左半边有序，再让右半边有序，再用O(n)的时间合并两个有序数组。有两种提高效率的方法：

* 当递归到数组长度很小时，改用插入排序。
* 如果左半边的最后一个元素<=右半边的第一个元素，跳过merge操作。

归并排序递归的写法很好理解，就是分治的思想。还有一种非递归的写法，是倍增的思想。写起来代码很短。

```cpp
for (int sz=1; sz<n; sz=sz+sz) {
	for (int j=0; j<n-sz; j+=sz+sz) {
		merge(j, j+sz, min(j+sz+sz, n));
		// [j, j+sz) [j+sz, min(j+sz+sz, n))
	}
}
```

## 冒泡排序

每次比较相邻两个元素，第i趟交换会导致第i大的放到当前无序数组的最后。每趟检测一下是否有交换，如果无交换就break。

```cpp
for (int i=n-1; i>=0; i--) {
	bool modi = false;
	for (int j=0; j<i; j++) {
		if (a[j] > a[j+1]) {
			swap(a[j], a[j+1]);
			modi = true;
		}
	}
	if (!modi) break;
}
```

## 快速排序

每次随机选一个种子，把比种子小的放到种子左边，比种子大的放到种子右边。递归左右两边。

实际上操作起来是，先把数组random_shuffle一下，然后每次选种子的时候都选第一个。

```cpp
int partition(int a[], int l, int r)
{
	int pivot = a[l];
	int i = l + 1, j = r; // 要维护的条件：a[l..i-1]<=pivot且a[i..r]>=pivot
	while (i <= j) {
		while (i <= r && a[i] < pivot) i ++;
		while (j >= l && a[j] > pivot) j --;
		if (i <= j) {
			swap(a[i], a[j]);
			i ++;
			j --;
		}
	}
	swap(a[i-1], a[l]);
	return i-1;
}

void sort(int a[], int l, int r)
{
	if (l >= r) return;
	int j = partition(a, l, r);
	sort(a, l, j-1);
	sort(a, j+1, r);
}

void sort(int a[], int n)
{
	random_shuffle(a, a+n);
	sort(a, 0, n-1);
}
```

改进快速排序同样有很多方法：

* 递归到短数组改用插入排序，一般阈值在5~15之间。
* 取前三个数的中位数作为pivot，然后把pivot放到第一个位置。
* 三向切分（很少用）。

## 堆排序

维护堆关键是两个操作（以小根堆为例）：

* 上浮：只要儿子比父亲小，就往上走。
* 下沉：每次选两个儿子里面较小的，往那个方向走。

构造堆的过程：从最后一个非叶节点开始，往前依次做下沉。时间复杂度O(n)。

排序的过程：依次删除最小值（或者输出，或者与数组最后一个元素交换），把根替换成最后一个元素，然后对根做下沉。

也就是说，对一个静态数组用堆排序，只需要用到下沉操作。如果要动态插入元素，才会用到上浮操作。

## 总结

以上排序都是基于比较的排序，参考资料是[《算法》](https://book.douban.com/subject/10432347/)这本书。实际上，如果单纯是排序这个问题的话，在C++语言里直接调用algorithm库里的sort函数就行了，所以理解算法的原理还有更深一步的作用，那就是融会贯通，在其他问题里使用这种思想。

### 第k小的数

如果暴力，复杂度O(kn)，如果再深入一点，用堆操作k次，复杂度O(klogn)。但是，如果使用快速排序的思想（而不是快速排序的代码），可以把复杂度降低到O(n)。

实际上在C++的STL里有nth\_element函数，所以使用起来还是只用调用就行了……如果想了解具体算法，可以去网上搜，或者看《算法》这本书（221页）。

## 其他排序算法

除了基于比较的算法，还有一些其他方法，这些排序算法依赖于数据本身的数字特征。但是优点是有可能突破O(nlogn)的下界，达到O(n)的复杂度；或者对空间复杂度有优化。

* 计数排序：对数字范围很小的数据很有效。开一个cnt数组，直接统计每个数字出现的次数。
* 桶排序：把数字分成若干个区间，对于每个区间里的数单独排序，可以对其他算法有空间上的优化。比如一千万个数，分成1000组，每组10000个数，如果对于需要O(n)辅助存储空间的算法，只需要10000的存储空间。
* 基数排序：最经典的是十进制基数，使用分配和回收操作，先比较个位，再比较十位，以此类推……