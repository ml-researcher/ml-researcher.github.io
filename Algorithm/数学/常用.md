# 常用

## GCD

GCD的原理很简单：

$gcd(a, b) = gcd(b, a\%b)$

具体证明参照[辗转相除法](https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95)。

```cpp
int gcd(int a, int b)
{
    if (b==0) return a;
    return gcd(b, a%b);
}
```

## 扩展欧几里得算法

```cpp
/*  求ax+by=c的整数解对 
 *  1.令m=gcd(a,b),A=a/m,B=b/m,
 *  2.如果能求出一组解(x0,y0)，那么任意解可以表示为(x0+kB,y0-kA)，k是任意整数
 *  3.设ax+by=m的一组解为(x1,y1)，那么 
 *    当c是m的倍数时ax+by=c的一组解 是(x1*c/m,y1*c/m) 
 *    否则无整数解 
 */

#include<cstdio>
 
int exgcd(int a, int b, int &x, int &y)
{
    if(b==0) {
        x = 1; y = 0;
        return a;
    }
    int r = exgcd(b, a%b, x, y);
    int t = x; x = y; y = t-a/b*y;
    return r;
}

int main()
{
	int a, b, c;
	scanf("%d%d%d", &a, &b, &c);
	int x, y;
	int m = exgcd(a, b, x, y);
	int A = a/m;
	int B = b/m;
	if (c % m == 0) {
		int x0 = c/m*x;
		int y0 = c/m*y;
		printf("Solution:");
		printf("(%d+(%d)*k,%d-(%d)*k)\n", x0, B, y0, A);
	}
	else printf("No solution.\n");
	return 0;
}

```

## 素数表

如何判断一个数是否是质数？$O(\sqrt{n})$。（当然也有[Miller-Rabin算法](https://blog.csdn.net/alps1992/article/details/51588971)……记得2017CCPC秦皇岛赛区热身赛还考了）

如何判断非常多次查询是否是素数？打个素数表$O(1)$查询。如果要打[1, n]的素数表，复杂度最低可以到$O(n)$，已经是理论下界了。为了好理解，我们循序渐进，先了解简单的$O(n \log \log n)$的埃氏筛法。

### Eratosthenes筛法

原理：素数的倍数一定不是素数。

实现：

```cpp
#define maxn 10000
bool check[maxn];
int prime[maxn];
int tot;
void getPrime()
{
	memset(check, false, sizeof(check));
	tot = 0;
	for (int i=2; i<=maxn; i++) {
		if (!check[i]) {
			prime[tot++] = i;
			for (int j=i+i; j<=maxn; j+=i) {
				check[j] = true;
			}
		}
	}
}
```

时间复杂度$O(n \log \log n)$，具体怎么来的可以参照[这个链接](https://stackoverflow.com/questions/2582732/time-complexity-of-sieve-of-eratosthenes-algorithm)，空间复杂度$O(n)$。

* [例题](http://codeforces.com/contest/1017/problem/F)，提示：bitset素数筛
	* [AC代码](http://lvqingsong.info/pastebin/view/7484cd12)

### Euler筛法

原理：让每个合数只被它最小的那个质因子筛掉一次。

原理很明白，但是怎么操作呢？确实如果以前没见过，直接让我写，我肯定写不出来，但是看着代码我能讲清楚是为什么（水平有限）。

```cpp
#define maxn 10000
bool check[maxn];
int prime[maxn];
int tot;
void getPrime()
{
	memset(check, false, sizeof(check));
	tot = 0;
	for (int i=2; i<=maxn; i++) {
		if (!check[i]) prime[tot++] = i;
		for (int j=0; j<tot; j++) {
			if (i*prime[j] > maxn) break;
			check[i*prime[j]] = true;
			if (i%prime[j] == 0) break;
		}
	}
}
```

其实一看代码就很显然了，基于一个这样的事实：每一个合数，必然可以被一个它最小的质数因子z和另一个整数x（质数或合数）相乘得到。其中x的最小的质数因子一定不会小于z。

其实最难理解的就是第二重循环。实际上明白了第二重循环的作用也就好理解了，第二重循环的作用是要把以$prime[j]$为最小质因子的合数筛掉。所以这就是为什么$i\%prime[j]==0$的时候要break，因为$i$已经有$prime[j]$作为质因子了，$i \times prime[j+1]$的最小质因子最大也只是$prime[j]$了。但是这实际上只解释了必要性，如何解释充分性呢？为什么只用了$check[i \times prime[j]]=true$，没有$check[i \times i \times prime[j]]=true$？因为只要一个数是合数，在轮到它作为i进行循环之前，必然已经被一个它的因子筛掉了。也就是说用$check[i \times prime[j]]=true$已经足够了。

## 组合数

众所周知，数字三角形的第i行的第j个数表示的是$C_i^j$（i和j都是从0开始编号），有时候我们要获得第i行第j列的一个组合数关于一个质数取模的结果，如果i很大j很小，可以用递推的方法。

$ C_i^{j+1} = C_i^j \times \frac{i-j}{j+1} $

那么，要求$C_n^m$，只需要预处理出[2, m]的逆元，然后从$C_n^0$递推m次即可。我给校赛出过的[一个题目](http://www.cnblogs.com/acmsong/p/8858331.html)就用到了这一点。

## 蔡勒公式

给定日期，返回星期几。

```cpp
//0 是星期日，1 是星期一……
int xq(int year, int month, int day)
{
	if (month < 3) {
		year -= 1;
		month += 12;
	}
	int c = int(year/100), y = year-100*c;
	int w = int(c/4)-2*c+y+int(y/4)+(26*(month+1)/10)+day-1;
	w = (w%7+7)%7;
	return w;
}
```

## 错排公式

当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推。

第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法；

第二步，放编号为k的元素，这时有两种情况：

⑴ 把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；
⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；

综上得到 D(n) = (n-1) [D(n-2) + D(n-1)]
特殊地，D(1) = 0, D(2) = 1。（注意：D(0) = 1）

## 数论分块

* [例题](https://www.lydsy.com/JudgeOnline/problem.php?id=1257)
	* [AC代码](http://lvqingsong.info/pastebin/view/b0751f57)

## 参考资料

* https://baike.baidu.com/item/错排公式/10978508
* https://blog.csdn.net/meopass/article/details/78083540