# 后缀数组

这一部分不讲原理，主要讲后缀数组能得到什么，以及如何应用。

一些基本概念：

* 一个长度为L的字符串有L个后缀，任意两个后缀按照字典序可比。
* sa[i]：排名第i的后缀下标。
* rk[i]：下标为i的后缀排名。
* height[i]：排名第i的和排名第i-1的后缀的最长公共前缀的长度。

两个算法：

* 倍增：O(nlogn)得到上面的数组。时间复杂度较高，代码短。
* DC3：O(n)得到上面的数组。时间复杂度较低，代码长。

## 应用

### 最长公共前缀

询问两个后缀的最长公共前缀。

根据两个后缀的rk，可以确定一段区间，这段区间里的height数组的min就是结果。

因此转换为RMQ问题。

### 最长重复子串

重复子串：一个子串在原串里至少出现两次。

#### 可重叠的最长重复子串

重复子串一定是某两个后缀的公共前缀。

所以height值最大的那两个相邻排名后缀的最长公共前缀就是结果。

rank不相邻的一定不是结果，因为最长公共前缀是height区间的min，不相邻只会更小。

复杂度$$O(n)$$。

#### 不可重叠的最长重复子串

二分长度，对于当前长度L，height数组被小于L的值分成了若干段，每一段看一下是否有不重叠的即可。对于每一段，只需要看sa的最大值减最小值是否大于等于L。

复杂度$$O(n \log n)$$。

#### 可重叠至少重复k次子串

论文里给的方法是二分，然后按L分割height以后，看每段里是否有不少于k个后缀。复杂度$$O(n \log n)$$。

实际上不需要二分，直接求height的连续k-1的滑窗最小值，取max即可，复杂度$$O(n)$$。

* [例题](http://poj.org/problem?id=3261)
	* [倍增 AC代码](http://lvqingsong.info/pastebin/view/b2afd385)
	* [DC3 AC代码](http://lvqingsong.info/pastebin/view/eb29abed)

### 不同子串个数

每个子串必定是某个后缀的前缀，所以要求一个字符串的不同子串的个数，就是要求所有后缀有多少个不同的前缀。按排名依次累加，第一名的后缀有n-sa[1]个，第二名及以后的后缀有n-sa[k]-height[k]个，也就是要减去跟前一名重复的。

### 最长公共子串

把两个字符串中间加一个未出现过的数$拼起来。然后求跨越$的最长公共前缀。

https://www.cnblogs.com/acmsong/p/7338065.html

### 连续重复子串

已知一个串是由某个子串重复若干次得到的，求最短的这个子串。

最好用kmp做，强行用后缀数组也行，虽然也是O(n)但是常数有点大。

### 重复次数最多的子串

https://www.cnblogs.com/acmsong/p/7302505.html

## 参考资料

* [后缀数组——处理字符串的有力工具 - 罗穗骞](http://lvqingsong.info/wp-content/uploads/2018/08/suffix-array.pdf)
* [kuangbin模板](http://lvqingsong.info/wp-content/uploads/2018/08/kuangbin.pdf)
* https://www.cnblogs.com/acmsong/category/1040263.html