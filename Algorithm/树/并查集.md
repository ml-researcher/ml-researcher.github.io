# 并查集

## 基础并查集

最常用的是路径压缩。

其次是启发式合并（有时候不允许压缩路径，就要用启发式合并），这种不起眼的优化在很多时候是从线性复杂度降到log的关键，所以很重要，务必掌握这种思想。

鉴于比较简单，就不细讲了。

## 并查集染色

findfa(i)维护的是i右边第一个没被染过的点。（包括i自己）

```cpp
// 初始化
for (int i=1; i<=maxn; i++) fa[i] = i;
// 要对[L,R]染色
for (int i=findfa(L); i<=R; i=findfa(i+1))
{
    color[i] = c;
    merge(i, R+1); // 把i的父亲指向R+1
}
```

## 带权并查集

本质上就是离散数学里的关系的传递性，对于给定题目，定义一个优雅的具有不错性质的运算，套进带权并查集。

* [例题1](http://poj.org/problem?id=1182)
* [例题2](https://leetcode.cn/problems/evaluate-division/)

比如说在这个例题1中，我们定义r(a,b)=0表示a和b是同类关系，r(a,b)=1代表a吃b，r(a,b)=2代表a被b吃。这样定义的厉害之处在于什么呢？它满足下面两个性质：

1. r(a,b)=(r(a,c)+r(c,b))%3
2. r(a,b)=(3-r(b,a))%3

这种性质让我们能一直维护fa[i]和r[i]，分别代表i的父亲和i与它父亲的关系。并且，对于处在同一个集合的任意两个元素，都可以$O(1)$地计算两者的关系。在上面的AC代码里有详细注释。

## 统计每个集合的大小

再维护一个数组即可，在合并的时候顺便维护一下。