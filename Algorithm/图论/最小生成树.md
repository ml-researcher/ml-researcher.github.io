# 最小生成树

最小生成树是最基础的图论题，算法主要有两个，都是贪心算法，下面还是先讲解两个算法的主要思想，然后再写几个例题。

## Kruskal

初始的时候图为空，每次加1条边，加n-1次之后形成最小生成树。关键在于加边策略。

Kruskal的贪心策略：把所有边按照权值从小到大排序，依次选取，如果选了一条边以后，在当前的形成的图里没有环，则加入该边。

如何判断是否成环呢？并查集。

总的时间复杂度是排序的复杂度加上并查集的时间复杂度。$O(E \log E + \alpha E)$，$\alpha$是带路径压缩的并查集的复杂度，可以看做$O(1)$。

## Prim

Prim是从点的角度来考虑的，初始的时候图为空，每次加1个点，加n次以后形成最小生成树。

Prim的贪心策略：把所有点分成两个集合——已经包含在最小生成树里的点集$A$和没有包含在最小生成树里的点集$B$。初始$A$为空，$B$里有n个点，目标就是不断扩充$A$最终形成一棵最小生成树。策略就是每次选一条从$A$中的点连到$B$中的点的边里面最短的，从而使得$A$扩充一个点，扩充n次就得到了最小生成树。（$A$为空的时候可以想像有一个虚的节点连向$B$中的一个点权值为0的边，其他点都是长度为$\infty$的边）

如何维护这个最小边权呢？维护一个w[]数组，w[i]表示$A$集合中的点连到i号点的最小边权。这个数组可以在$A$扩充的过程中$O(E)$地维护，但是选最小的过程就是$O(n^2)$的了。当然有堆优化的方法，但是实际很少用。因为Prim唯一的优势就是代码量少了，如果再考虑其他优化，还不如直接用Kruskal。

当然，为了知识点的全面，还是讲一下吧。要搞清楚一个逻辑：通过维护未进入当前MST的点到已知点的最短距离来做，随着已知点越来越多，从而可以维护。但是实现的时候，是通过relax新加入的已知点来写。

## 例1：Jungle Roads

[题目链接](http://poj.org/problem?id=1251)

这么小的数据范围，$O(n^2)$暴力很容易操作了。

[AC代码](http://lvqingsong.info/pastebin/view/db37fe9f)

## 例2：Constructing Roads

[题目链接](http://poj.org/problem?id=2421)

本来也是可以直接用Prim暴力跑，但是为了使用一些Kruskal，还是强行用了Kruskal。

[AC代码](http://lvqingsong.info/pastebin/view/b5fcf3d7)

## 次小生成树

用Kruskal求出最小生成树以后，枚举没在MST里面的边，加进去，必然成环，在环上删去除了新加的这条边以外的边里面权值最大的那个，得到的就是次小生成树的一个候选，所有候选里权值最小的就是次小生成树。

具体操作的时候就是，得到最小生成树以后预处理任意两点间的最大边，处理方法是树上倍增。然后枚举所有不在最小生成树上的边，加边之前先去掉路径上的最大边。复杂度$O(m \log n)$。

还有另一种方法就是直接枚举所有最小生成树上的边，不选这条边做MST。复杂度$O(mn)$。

## 曼哈顿最小生成树

[例题](https://open.kattis.com/problems/gridmst)

结论：真正有用的边远没有$O(n^2)$条。我们考虑每个点会和其他一些什么样的点连边。可以得出这样一个结论，以一个点为原点建立直角坐标系，在每45度内只会向距离该点最近的一个点连边。

具体我也没细研究，感兴趣的话了解一下吧。

## 参考资料

* https://www.byvoid.com/zhs/blog/2-sp-mst
* https://blog.csdn.net/huzecong/article/details/8576908
* https://oi.men.ci/minimum-spanning-tree-notes/